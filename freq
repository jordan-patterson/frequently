#!/usr/bin/env python3

import os
import webbrowser
from clmenu import getch,Menu,printLogo
import yaml
import argparse
import pickle
import subprocess as sub

getch=getch()

def getDict(filename):
	'''
		returns a dictionary saved from a yaml file
	'''
	with open(filename,"r") as file:
		data=yaml.load(file)
	return data

def addSite():
	try:
		sites=getDict("sites.yaml")
	except:
		#file not found, create new dict
		sites={}
	printLogo("logo.txt")
	name=input("\n\n\t\t\tName of website: ")
	url=input("\n\n\t\t\tAddress of website: ")
	sites[name]=url
	update("sites.yaml",sites)

def openSite():
	try:
		sites=getDict("sites.yaml")
	except:
		printLogo("logo.txt")
		print("\n\t\t\t\tError: There were no sites found.")
		getch()
		return None
	options=list(sites.keys())
	options.append("GO BACK")
	instructions="\t\t  WHAT SHOULD I OPEN?"
	menu=Menu(options,instructions,"logo.txt")
	temp=0
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp!=len(options)-1):
			webbrowser.open_new_tab("https://"+sites[options[temp]])

def addNewStartSite():
	try:
		sites=getDict("sitesOnStartUp.yaml")
	except:
		sites={}
	printLogo("logo.txt")
	name=input("\n\n\n\t\t\tName of website: ")
	url=input("\n\n\t\t\tAddress of website (www.example.com): ")
	sites[name]=url
	update("sitesOnStartUp.yaml",sites)

def addExistingStartSite():
	try:
		sites=getDict("sites.yaml")
	except:
		printLogo("logo.txt")
		print("\n\n\t\t\t\tError: No websites were found")
		getch()
		return None
	options=list(sites.keys())
	options.append("GO BACK")
	instructions="\n\t\t\t\tWHAT WEBSITE SHOULD I ADD?"
	menu=Menu(options,instructions,"logo.txt")
	temp=menu.prompt()
	if(temp!=len(options)-1):
		try:
			startupSites=getDict("sitesOnStartUp.yaml")
		except:
			startupSites={}
		finally:
			startupSites[options[temp]]=sites[options[temp]]
			update("sitesOnStartUp.yaml",startupSites)

def addStartUpWebsite():
	options=["NEW","EXISTING","GO BACK"]
	instructions="SELECT THE TYPE"
	menu=Menu(options,instructions,"logo.txt")
	temp=9
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp==0):
			addNewStartSite()
		elif(temp==1):
			addExistingStartSite()

#takes a filename and a dictionary as arguments, overwrites the file with dictionary
def update(filename,dictionary):
	with open(filename,'w') as file:
		yaml.dump(dictionary,file)

def removeSite(filename):
	try:
		sites=getDict(filename)
	except:
		printLogo("logo.txt")
		print("\n\n\t\t\t\tError: There are no sites to remove")
		getch()
		return None
	options=list(sites.keys())
	options.append("GO BACK")
	instructions="\n\n\t\t\t\tWHAT SHOULD I REMOVE?"
	menu=Menu(options,instructions,"logo.txt")
	temp=menu.prompt()
	if(temp!=len(options)-1):
		del sites[options[temp]]
		update(filename,sites)

def website():
	options=["OPEN WEBSITE","ADD WEBSITE","REMOVE WEBSITE","ADD WEBSITE ON STARTUP","REMOVE WEBSITE FROM STARTUP","GO BACK"]
	instructions="\tWHAT ACTION SHOULD I TAKE?"
	menu=Menu(options,instructions,"logo.txt")
	temp=0
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp==0):
			openSite()
		elif(temp==1):
			addSite()
		elif(temp==2):
			removeSite("sites.yaml")
		elif(temp==3):
			addStartUpWebsite()
		elif(temp==4):
			removeSite("sitesOnStartUp.yaml")

def openTextEditor():
	if(not os.path.exists("config.yml")):
		printLogo("logo.txt")
		editor=input("\n\n\t\t\t\tName of text editor: ")
		with open("config.yml","a") as file:
			yaml.dump({"editor":editor},file)
	with open("config.yml","r") as file:
		data=yaml.load(file)
	editor=data["editor"]
	os.system(editor)

def addScript():
	try:
		scripts=getDict("scripts.yml")
	except:
		scripts={}
	printLogo("logo.txt")
	name=input("\n\n\n\t\t\tEnter the name of the script: ")
	path=''
	while(not os.path.exists(path)):
		path=input("\n\n\t\t\tEnter a valid path to where the script is located:")
	scripts[name]=path
	update("scripts.yml",scripts)

def addNewStartupScript():
	try:
		scripts=getDict("startupScripts.yml")
	except:
		#create new dict
		scripts={}
	printLogo("logo.txt")
	name=input("\n\n\t\t\t Enter the name you wish to call the executable: ")
	path=''
	while(not os.path.exists(path)):
		path=input("\n\n\t\t\t Enter a valid path to where the exec is located: ")
	scripts[name]=path
	update("startupScripts.yml",scripts)

def addExistingStartupScript():
	try:
		existing_scripts=getDict("scripts.yml")
	except:
		printLogo("logo.txt")
		print("\n\n\t\t\t\tError: No scripts were found")
		getch()
		return None
	options=list(existing_scripts.keys())
	options.append("GO BACK")
	instructions="\tWHAT EXECUTABLE SHOULD I ADD?"
	menu=Menu(options,instructions,"logo.txt")
	temp=menu.prompt()
	if(temp!=len(options)-1):
		try:
			scripts=getDict("startupScripts.yml")
		except:
			scripts={}
		finally:
			scripts[options[temp]]=existing_scripts[options[temp]]
			update("startupScripts.yml",scripts)

def addScriptOnStartup():
	options=["NEW","EXISTING","GO BACK"]
	instructions="\t   SELECT THE TYPE"
	menu=Menu(options,instructions,"logo.txt")
	temp=9
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp==0):
			addNewStartupScript()
		elif(temp==1):
			addExistingStartupScript()

def removeScript(filename):
	try:
		scripts=getDict(filename)
	except:
		printLogo("logo.txt")
		print("\n\n\t\t\tError: There are no scripts to remove")
		getch()
		return None
	options=list(scripts.keys())
	options.append("GO BACK")
	instructions="\t  What should I remove?"
	menu=Menu(options,instructions,"logo.txt")
	temp=menu.prompt()
	if(temp!=len(options)-1):
		del scripts[options[temp]]
		update(filename,scripts)

def run(path):
	maindir=os.getcwd()
	executable=path.split('/')[-1]#obtain name of executable from path
	path=path.strip(executable)
	os.chdir(path)#go to directory where executable is located
	os.system("gnome-terminal -e './"+executable+"'")
	os.chdir(maindir)#return back to program's directory

def runScript():
	try:
		scripts=getDict("scripts.yml")
	except:
		printLogo("logo.txt")
		print("\n\n\t\t\t\tError: There were no executables found")
		getch()
		return None
	options=list(scripts.keys())
	options.append("GO BACK")
	instructions="\t  Select the executable you want to run"
	menu=Menu(options,instructions,"logo.txt")
	temp=0
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp!=len(options)-1):
			run(scripts[options[temp]])

def scripts():
	options=["RUN EXECUTABLE","ADD EXECUTABLE","REMOVE","ADD ON STARTUP","REMOVE ON STARTUP","GO BACK"]
	instructions="\t What action should I take?"
	menu=Menu(options,instructions,"logo.txt")
	temp=0
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp==0):
			runScript()
		elif(temp==1):
			addScript()
		elif(temp==2):
			removeScript("scripts.yml")
		elif(temp==3):
			addScriptOnStartup()
		elif(temp==4):
			removeScript("startupScripts.yml")

def openTerminal():
	terminal_commands=["konsole","xterm","gnome-terminal"]
	for i in range(len(terminal_commands)):
		try:
			sub.Popen([terminal_commands[i]],stdout=sub.PIPE,stderr=sub.PIPE)
			break
		except:
			continue

def removeCommand(filename):
	commands=getCommands(filename)
	if(commands):
		commands.append("GO BACK")
		instructions="\t SELECT A COMMAND TO REMOVE"
		menu=Menu(commands,instructions,"logo.txt")
		temp=menu.prompt()
		if(temp!=len(commands)-1):
			commands.remove(commands[temp])
			commands.remove("GO BACK")
			#update file
			updateCommands(commands,filename)
	else:
		printLogo("logo.txt")
		print("\n\t\t\t\tError: There are no commands to be removed")
		getch()

def removeCommands():
	options=["REMOVE FROM STARTUP","OTHER","GO BACK"]
	instructions="WHAT SHOULD I REMOVE?"
	menu=Menu(options,instructions,"logo.txt")
	temp=0
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp==0):
			removeCommand("commandOnStart.dat")
		elif(temp==1):
			removeCommand("commands.dat")

def updateCommands(commands,filename):
	with open(filename,"wb") as file:
		pickle.dump(commands,file)

def addExisitingCommandOnStart():
	commands=getCommands("commands.dat")
	if(commands):
		commands.append("GO BACK")
		instructions="SELECT A COMMAND"
		menu=Menu(commands,instructions,"logo.txt")
		temp=menu.prompt()
		if(temp!=len(commands)-1):# if commands[temp]!="GO BACK"
			addCommand(commands[temp],"commandOnStart.dat")
	else:
		printLogo("logo.txt")
		print("\n\t\t\t\tError: No existing commands were found")
		getch()

def addCommandOnStartup():
	options=["NEW","EXISTING","GO BACK"]
	instructions="\tSELECT THE TYPE"
	menu=Menu(options,instructions,"logo.txt")
	temp=0
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp==0):
			printLogo("logo.txt")
			command=input("\n\t\t\t\tENTER THE COMMAND: ")
			addCommand(command,"commandOnStart.dat")
		elif(temp==1):
			addExisitingCommandOnStart()

def addCommand(command,filename):
	commands=getCommands(filename)
	if(commands):
		commands.append(command)
	else:
		#create new list
		commands=[command]
	#overwrite or add updated list to file
	updateCommands(commands,filename)

def getCommands(filename):
	'''
		returns a list of strings saved to a file called filename
	'''
	try:
		file=open(filename,"rb")
		commands=pickle.load(file)
		return commands
	except:
		return None

def runCommand():
	commands=getCommands("commands.dat")
	if(commands):
		commands.append("GO BACK")
		instructions="Which command should I run?"
		menu=Menu(commands,instructions,"logo.txt")
		temp=menu.prompt()
		if(temp!=len(commands)-1):#if commands[temp]!="GO BACK"
			startCommand(commands[temp])
	else:
		printLogo("logo.txt")
		print("\n\t\t\t\tError: No commands were found")
		getch()

def commands():
	options=["RUN COMMAND","ADD COMMAND","ADD COMMAND ON STARTUP","REMOVE","GO BACK"]
	instructions="What action should I take?"
	menu=Menu(options,instructions,"logo.txt")
	temp=0
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp==0):
			runCommand()
		elif(temp==1):
			printLogo("logo.txt")
			command=input("\n\t\t\t\tEnter the new command: ")
			addCommand(command,"commands.dat")
		elif(temp==2):
			addCommandOnStartup()
		elif(temp==3):
			removeCommands()

def main():
	options=["COMMAND","WEBSITE","EXECUTABLE","TERMINAL","TEXT EDITOR","EXIT"]
	instructions=" "
	menu=Menu(options,instructions,"logo.txt")
	temp=9
	while(temp!=len(options)-1):
		temp=menu.prompt()
		if(temp==0):
			commands()
		elif(temp==1):
			website()
		elif(temp==2):
			scripts()
		elif(temp==3):
			openTerminal()
		elif(temp==4):
			openTextEditor()

def startCommand(command):
	terminal_commands=["konsole","gnome-terminal","xterm"]
	for terminal in terminal_commands:
		try:
			sub.Popen([terminal,'-e',command],stdout=sub.PIPE,stderr=sub.PIPE)
			break
		except:
			continue

def startAllCommands():
	commands=getCommands("commandOnStart.dat")
	if(commands):
		for command in commands:
			startCommand(command)

def startallWebsites():
	try:
		sites=getDict("sitesOnStartUp.yaml")
	except:
		return None
	for site in sites.items():
		webbrowser.open_new_tab("https://"+site[1])

def startAllScripts():
	try:
		scripts=getDict("startupScripts.yml")
	except:
		return None
	for script in scripts.items():
		run(script[1])

if __name__=="__main__":
	parser=argparse.ArgumentParser(prog="Frequently")
	parser.add_argument('-a','--all',help="Starts all listed scripts and websites on start",action="store_true")
	parser.add_argument('-w','--web',help="Starts all listed websites on start",action="store_true")
	parser.add_argument('-e','--ex',help="Starts all listed executables on start",action="store_true")
	parser.add_argument('-c','--co',help="Starts all listed commands on start",action="store_true")
	args=parser.parse_args()
	if(args.all):
		startallWebsites()
		startAllScripts()
		startAllCommands()
	elif(args.web):
		startallWebsites()
	elif(args.ex):
		startAllScripts()
	elif(args.co):
		startAllCommands()
	main()
	#website()